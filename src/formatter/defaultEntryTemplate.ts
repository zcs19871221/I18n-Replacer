export default function defaultEntry(localeFiles: string[]) {
  return `
  /*
 * This file is automatic generated by fast-i18n.
 * All changes will be cleared
 * after rerun fast-i18n program.
 * Or you can implement an I18nFormatter class and use that class as the I18nFormatterClass parameter for api invoke.
 */
import React, {
  ReactNode,
  createContext,
  useContext,
  useMemo,
  useLayoutEffect,
} from 'react';
import {
  IntlProvider,
  createIntl,
  createIntlCache,
  IntlCache,
  IntlShape,
} from 'react-intl';
import type { AvailableLocales, LocalKey } from './types';

export interface LocaleContextValue {
  readonly locale: AvailableLocales | null;
  readonly messages: Record<LocalKey, string> | null;
  readonly switch: (locale: AvailableLocales) => Promise<void>;
}

class I18n {
  public get locale() {
    return this.currentLocale;
  }

  public get intl(): IntlShape|null {
    return this.currentIntl;
  }

  public get messages():  Record<LocalKey, string>|null {
    return this.currentMessages;
  }

  public async switch(locale: AvailableLocales) {
    if (locale === this.currentLocale) {
      return;
    }
    let messages: Record<LocalKey, string> | null = null;
    switch (locale) {
      ${localeFiles
        .map(
          (name) => `
                  case '${name}':
                    messages = ((await import('./${name}.ts')) as any).default;
                    break;
            `
        )
        .join('')}
      default: {
        const error: never = locale;
        throw new Error(error);
      }
    }
    if (messages) {
      this.currentMessages = messages;
      this.currentLocale = locale;
      this.currentIntl = createIntl(
        {
          locale: this.currentLocale,
          messages,
        },
        this.cache
      );
      document.documentElement.lang = locale;
    }
  }

  private currentLocale: AvailableLocales | null = null;

  private cache: IntlCache = createIntlCache();

  private currentIntl: IntlShape|null = null;

  private currentMessages: Record<LocalKey, string> | null = null;
}

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace FormatjsIntl {
    interface Message {
      ids: LocalKey;
    }
  }

  interface Window {
    readonly i18n: I18n;
  }
}

const LocaleContext = createContext<LocaleContextValue | undefined>(undefined);

export function useLocale(): LocaleContextValue {
  const context = useContext(LocaleContext);

  if (context === undefined) {
    throw new Error('useLocale must be used within the LocaleProvider context');
  }

  return context;
}
const i18n = new I18n();

export function LocaleProvider({
  children,
  fallback,
  defaultLocale,
}: {
  defaultLocale: AvailableLocales;
  children: ReactNode;
  fallback?: React.ReactNode;
}) {
  const value = useMemo(
    (): LocaleContextValue => ({
      locale: i18n.locale,
      switch: i18n.switch,
      messages: i18n.messages,
    }),
    [i18n.locale, i18n.switch, i18n.messages]
  );

  useLayoutEffect(() => {
    i18n.switch(defaultLocale);
  }, [defaultLocale]);

  return (
    <LocaleContext.Provider value={value}>
      {(value.messages && value.locale) ? (
        <IntlProvider locale={value.locale} messages={value.messages}>
          {children}
        </IntlProvider>
      ) : (
        fallback
      )}
    </LocaleContext.Provider>
  );
}

//@ts-ignore
window.i18n = new I18n();

export { i18n };
`;
}
